---
title: "ETF Data Analysis"
format: 
  html:
    code-fold: true
    code-summary: "Show Code"
vignette: >
  %\VignetteIndexEntry{ETF Data Analysis}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| label: setup
#| include: false
#| error: true

# Robust Setup for CI
data_loaded <- FALSE
universe <- NULL
metadata <- NULL
history <- NULL
is_ci <- identical(Sys.getenv("CI"), "true")

tryCatch({
  suppressPackageStartupMessages({
    library(etfdata)
    if (requireNamespace("ggplot2", quietly = TRUE)) library(ggplot2)
    if (requireNamespace("dplyr", quietly = TRUE)) library(dplyr)
    if (requireNamespace("targets", quietly = TRUE)) library(targets)
    if (requireNamespace("stringr", quietly = TRUE)) library(stringr)
  })

  # Strategy: Load snapshot from installed package (CI) or source (Local)
  snapshot_file <- "vignette_data.rds"
  data_path <- system.file("extdata", snapshot_file, package = "etfdata")
  
  if (data_path == "" || !file.exists(data_path)) {
    # Try relative source path (Local dev)
    data_path <- file.path("..", "inst", "extdata", snapshot_file)
  }

  if (file.exists(data_path)) {
    snap <- readRDS(data_path)
    universe <- snap$universe
    metadata <- snap$metadata
    history <- snap$history
    data_loaded <- TRUE
  } else {
    # Robust fallback to targets
    store_path <- NULL
    possible_paths <- c("_targets", "../_targets", "../../_targets")
    for (p in possible_paths) {
      if (dir.exists(p)) {
        store_path <- p
        break
      }
    }
    
    if (!is.null(store_path) && requireNamespace("targets", quietly = TRUE)) {
      tar_config_set(store = store_path)
      try({
        universe <- tar_read(universe)
        metadata <- tar_read(metadata)
        history <- tar_read(history)
        data_loaded <- TRUE
      }, silent = TRUE)
    }
  }
}, error = function(e) {
  message("Setup failed: ", e$message)
})
```

## ETF Universe

We start by defining the universe of European UCITS ETFs. 

**Note:** The data displayed in this vignette is a subset (Top 5 by AUM) generated during the build process.

The logic used to retrieve the universe list is:

```{r universe-code}
#| echo: true
#| eval: false
get_etf_universe <- function() {
  path <- system.file("extdata", "seed_universe.csv", package = "etfdata")
  if (path == "") {
    # Fallback for development if package not installed
    path <- "inst/extdata/seed_universe.csv"
  }
  
  if (!file.exists(path)) {
    # Try one level up if running from package root
    if (file.exists("inst/extdata/seed_universe.csv")) {
        path <- "inst/extdata/seed_universe.csv"
    } else {
        stop("Seed universe file not found at: ", path)
    }
  }
  
  readr::read_csv(path, show_col_types = FALSE)
}
```

```{r universe-table}
#| echo: false
#| eval: true
if (data_loaded && !is.null(universe)) {
  knitr::kable(head(universe, 10))
  print(head(universe, 10))
} else {
  print("Universe data not available in this build.")
}
```

## Metadata (JustETF)

We scrape JustETF for metadata including AUM and TER. The underlying scraping logic (simplified) looks like this:

```{r metadata-code}
#| echo: true
#| eval: false
fetch_etf_metadata <- function(isin) {
  # Handle vector input
  if (length(isin) > 1) {
    return(purrr::map_dfr(isin, fetch_etf_metadata))
  }

  url <- paste0("https://www.justetf.com/uk/etf-profile.html?isin=", isin)
  
  # Polite delay
  Sys.sleep(runif(1, 1, 2))
  
  req <- request(url) %>%
    req_headers("User-Agent" = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/115.0")
  
  resp <- try(req_perform(req), silent = TRUE)
  
  if (inherits(resp, "try-error")) {
    warning("Failed to fetch metadata for ", isin)
    return(tibble(isin = isin))
  }
  
  if (resp_status(resp) != 200) {
    warning("HTTP error ", resp_status(resp), " for ", isin)
    return(tibble(isin = isin))
  }
  
  html <- resp_body_html(resp)
  tables <- html_table(html)
  
  # Helper to extract value from key-value tables (X1, X2)
  get_val <- function(key_pattern) {
    # Search all tables for the key
    for (tbl in tables) {
      if (ncol(tbl) >= 2) {
        # Check if first col contains key
        match <- tbl[str_detect(tbl[[1]], key_pattern), ]
        if (nrow(match) > 0) {
          return(match[[2]][1])
        }
      }
    }
    return(NA_character_)
  }
  
  # Extract fields
  aum_raw <- get_val("Fund size")
  ter_raw <- get_val("Total expense ratio")
  replication <- get_val("Replication")
  dist_policy <- get_val("Distribution policy")
  domicile <- get_val("Fund domicile")
  
  tibble(
    isin = isin,
    aum_text = aum_raw,
    ter_text = ter_raw,
    replication = replication,
    distribution = dist_policy,
    domicile = domicile,
    source_url = url
  )
}
```

```{r metadata-table}
#| echo: false
#| eval: true
if (data_loaded && !is.null(metadata)) {
  # Check if columns exist before selecting
  cols <- c("isin", "aum_text", "ter_text", "replication")
  cols <- intersect(cols, colnames(metadata))
  if (length(cols) > 0) {
    knitr::kable(head(metadata[, cols, drop=FALSE], 10))
    print(head(metadata, 10))
  }
} else {
  print("Metadata not available.")
}
```

## JustETF Screener API

In addition to scraping specific ISINs, we can query the JustETF screener directly to find ETFs meeting specific criteria (e.g., AUM > £200m, TER < 0.75%).

```{r screener-code}
#| echo: true
#| eval: false
screener_results <- fetch_justetf_screener(min_aum_gbp = 200, max_ter = 0.75)
print(head(screener_results))
```

## Price History (Yahoo Finance)

We fetch daily price history from Yahoo Finance using `quantmod`.

```{r history-code}
#| echo: true
#| eval: false
fetch_price_history("VUSA.L")
```

```{r history-plot, echo=TRUE, message=FALSE, warning=FALSE}
is_ci <- isTRUE(get0("is_ci", ifnotfound = FALSE))
if (is_ci) {
  message("Skipping history plot in CI.")
} else if (data_loaded && !is.null(history) && requireNamespace("ggplot2", quietly = TRUE)) {
  # Visualize Close Prices with Facets
  print(
    history %>%
      ggplot(aes(x = date, y = close, color = ticker)) +
      geom_line() +
      facet_wrap(~ticker, scales = "free_y") +
      labs(title = "ETF Price History (LSE)", y = "Close Price (GBP)") +
      theme_minimal() +
      theme(legend.position = "none")
  )
  print(history)
}
```

```{r history-plot-static, echo=FALSE}
# Static fallback for CI
if (isTRUE(get0("is_ci", ifnotfound = FALSE))) {
  knitr::include_graphics("history_plot.png")
}
```

## Combined Analysis

We join the datasets and parse the AUM strings to analyze the relationship between Fund Size, Liquidity, and Fees.

```{r combined, echo=TRUE, message=FALSE, warning=FALSE}
if (data_loaded && !is.null(history) && !is.null(metadata)) {
  avg_vol <- history %>%
    group_by(ticker) %>%
    summarise(avg_daily_vol = mean(volume, na.rm = TRUE))
  
  if ("isin" %in% colnames(universe) && "isin" %in% colnames(metadata)) {
    combined <- universe %>%
      inner_join(metadata, by = "isin") %>%
      inner_join(avg_vol, by = "ticker")
    
    if (requireNamespace("stringr", quietly = TRUE) && requireNamespace("dplyr", quietly = TRUE)) {
       combined <- bind_cols(combined, parse_aum(combined$aum_text))
    }

    if (requireNamespace("readr", quietly = TRUE) && requireNamespace("stringr", quietly = TRUE)) {
      combined <- combined %>%
        mutate(
          ter_val = readr::parse_number(ter_text),
          ter_units = stringr::str_extract(ter_text, "[%]") 
        )
    }

    cols_to_show <- c("ticker", "name", "currency", "aum_amount", "aum_units", "avg_daily_vol", "ter_val")
    cols_to_show <- intersect(cols_to_show, colnames(combined))
    knitr::kable(head(combined %>% select(all_of(cols_to_show))))
  }
} else {
  print("Combined data not available for this build.")
}
```

```{r combined-plot-liquidity, echo=TRUE, message=FALSE, warning=FALSE}
if (exists("combined") && requireNamespace("ggplot2", quietly = TRUE)) {
  print(
    ggplot(combined, aes(x = total_amount, y = avg_daily_vol)) +
      geom_point() +
      scale_x_log10(labels = scales::label_currency(prefix = "£", scale_cut = scales::cut_short_scale())) +
      scale_y_log10(labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
      labs(title = "ETF Size vs Liquidity",
           x = "Assets Under Management (AUM in GBP)",
           y = "Average Daily Volume") +
      theme_minimal()
  )
}
```

```{r combined-plot-ter, echo=TRUE, message=FALSE, warning=FALSE}
if (exists("combined") && "ter_val" %in% colnames(combined) && requireNamespace("ggplot2", quietly = TRUE)) {
  print(
    ggplot(combined, aes(x = total_amount, y = ter_val)) +
      geom_point() +
      scale_x_log10(labels = scales::label_currency(prefix = "£", scale_cut = scales::cut_short_scale())) +
      labs(title = "ETF Size vs Cost (TER)",
           x = "Assets Under Management (AUM in GBP)",
           y = "Total Expense Ratio (%)") +
      theme_minimal()
  )
} else if (exists("combined")) {
  print("TER data not available for plotting (ter_val column missing).")
} else {
  print("Combined data not available for plotting.")
}
```

```{r combined-plot-static, echo=FALSE}
if (!exists("combined") || !requireNamespace("ggplot2", quietly = TRUE)) {
  knitr::include_graphics("combined_plot.png")
}
```

# Reproducibility & Metadata

## Session Info

<details>
<summary>Click to expand Session Info</summary>
```{r session-info}
sessionInfo()
```
</details>

## Data Structures

<details>
<summary>Click to expand Data Structures</summary>
```{r data-sizes}
if (data_loaded) {
  print("Universe:")
  print(head(universe, 10))
  print("Metadata:")
  print(head(metadata, 10))
  print("History:")
  print(head(history, 10))
}
```
</details>

## Targets Metadata

<details>
<summary>Click to expand Targets Metadata</summary>
```{r targets-meta, results='asis'}
#| echo: false
#| eval: true
#| message: false
#| warning: false
#| error: true

is_ci <- isTRUE(get0("is_ci", ifnotfound = FALSE))

if (requireNamespace("targets", quietly = TRUE) && 
    requireNamespace("visNetwork", quietly = TRUE)) {
  
  # Robust path finding for _targets and _targets.R
  store_path <- NULL
  possible_paths <- c("_targets", "../_targets", "../../_targets")
  for (p in possible_paths) {
    if (dir.exists(p)) {
      store_path <- p
      break
    }
  }
  
  script_path <- NULL
  possible_scripts <- c("_targets.R", "../_targets.R", "../../_targets.R")
  for (s in possible_scripts) {
    if (file.exists(s)) {
      script_path <- s
      break
    }
  }
  
  if (!is.null(store_path)) {
    # Set config for this session
    try(tar_config_set(store = store_path), silent = TRUE)
    if (!is.null(script_path)) {
      try(tar_config_set(script = script_path), silent = TRUE)
    }
    
    # 1. Meta Table
    try({
      if (!is.null(tar_meta(store = store_path))) {
        meta <- tar_meta(store = store_path)
        
        # Format bytes to human readable
        format_bytes <- function(b) {
          if (is.na(b)) return("NA")
          if (b < 1024) return(paste0(b, " B"))
          if (b < 1024^2) return(paste0(round(b / 1024, 1), " KB"))
          return(paste0(round(b / 1024^2, 1), " MB"))
        }
        
        meta$bytes_formatted <- sapply(meta$bytes, format_bytes)
        
        # Sort and select
        meta_disp <- meta[order(meta$bytes, decreasing = TRUE), ]
        meta_disp <- head(meta_disp, 5)
        meta_disp <- meta_disp[, c("name", "bytes_formatted", "seconds", "time", "type")]
        
        if (nrow(meta_disp) > 0) {
          print(knitr::kable(meta_disp, caption = "Targets Pipeline Metadata (Top 5)"))
        }
      }
    }, silent = TRUE)
    
    # 2. Pipeline Visualization
    cat("\n### Pipeline Network\n")
    if (!is_ci) {
      tryCatch({
        vn <- tar_visnetwork(store = store_path, targets_only = TRUE)
        print(vn)
      }, error = function(e) {
        message("Could not generate visNetwork: ", e$message)
      })
    } else {
      # Fallback: Print Manifest Table
      if (!is.null(script_path)) {
        try({
          man <- tar_manifest(fields = c("name", "command"))
          print(knitr::kable(head(man, 10), caption = "Pipeline Manifest (CI Fallback)"))
        })
      } else {
        message("Pipeline manifest skipped (script not found in CI).")
      }
    }
    
  } else {
    message("Targets store not found. Checked: ", paste(possible_paths, collapse = ", "))
  }
}
```
</details>
