---
title: "ETF Data Dashboard (Shinylive)"
format: 
  html:
    self-contained: false
    embed-resources: false
    resources:
      - shinylive-sw.js
      - ../inst/extdata/seed_universe.csv
      - ../inst/extdata/vignette_data.rds
    header-includes:
      - |
        <script>
        // Manually register the Service Worker at the root scope to fix path issues in pkgdown
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('shinylive-sw.js', { scope: '.' })
            .then((reg) => console.log('Manual SW registration success:', reg))
            .catch((err) => console.error('Manual SW registration failed:', err));
        }
        </script>
engine: knitr
filters:
  - shinylive
webr:
  version: 0.5.0
  packages:
    - shiny
    - dplyr
    - ggplot2
    - DT
    - htmltools
    - httr2
    - janitor
    - readr
    - stringr
    - purrr
    - lubridate
    - tzdb
    - vroom
    - bit
    - bit64
    - clipr
    - crayon
    - munsell
    - scales
  repos:
    - https://johngavin.github.io/etf-data/
vignette: >
  %\VignetteIndexEntry{ETF Data Dashboard (Shinylive)}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

This vignette presents an interactive Shiny dashboard, powered by Shinylive and WebR, allowing you to explore and filter ETF data directly in your browser.

```{r setup, include=FALSE}
# These libraries are implicitly loaded by shinylive configuration
# library(shiny)
# library(dplyr)
# library(ggplot2)
# library(DT)
```

```{shinylive-r}
#| standalone: true
#| viewerHeight: 800

webr_repo <- "https://johngavin.github.io/etf-data/"
options(repos = c(CRAN = webr_repo))

ensure_webr_packages <- function(pkgs) {
  installed <- rownames(installed.packages())
  missing <- setdiff(pkgs, installed)
  if (length(missing) == 0) {
    return(invisible(TRUE))
  }
  if (!requireNamespace("webr", quietly = TRUE)) {
    stop("Missing packages in WebR session: ", paste(missing, collapse = ", "))
  }
  webr::install(missing, repos = webr_repo)
}

ensure_webr_packages(c(
  "munsell",
  "scales",
  "gtable",
  "isoband",
  "farver",
  "labeling",
  "RColorBrewer",
  "viridisLite",
  "S7"
))

library(shiny)
library(dplyr)
library(ggplot2)
library(DT)
library(htmltools)
library(httr2)
library(janitor)
library(readr)
library(stringr)

# --- Helper Functions (Embedded for WASM) ---

fetch_justetf_screener <- function(min_aum_gbp = 200, max_ter = 0.75) {
  
  # Endpoint often used by the screener
  # Note: This is an internal API and may change.
  url <- "https://www.justetf.com/api/etfs/en/search"
  
  # Construct the request
  # 'draw', 'start', 'length' are DataTables parameters
  # 'lang' and 'country' usually passed in body or query
  req <- httr2::request(url) %>%
    httr2::req_body_json(list(
      draw = 1,
      start = 0,
      length = -1, # Fetch all
      search = list(value = "", regex = FALSE),
      # Filter for LSE listings roughly corresponds to `exchange` or similar params in some variations
      # But often the main search returns all. We filter post-fetch.
      # However, we can try to restrict to ETFs available in UK.
      country = "GB",
      universeType = "private"
    )) %>%
    httr2::req_headers(
      "User-Agent" = "Mozilla/5.0 (R; etfdata package)",
      "Content-Type" = "application/json"
    )
  
  # Perform request
  resp <- httr2::req_perform(req)
  
  # Parse JSON
  json_data <- httr2::resp_body_json(resp)
  
  # Extract the 'data' element which contains the list
  if (is.null(json_data$data)) {
    warning("No data found in JustETF response.")
    return(dplyr::tibble())
  }
  
  # Convert to tibble
  # The list items might be varying in length/structure, bind_rows usually handles it
  df <- dplyr::bind_rows(json_data$data) %>%
    janitor::clean_names()
  
  if (nrow(df) == 0) {
    return(df)
  }
  
  # Process and Filter
  # Fields often returned: "isin", "name", "ter", "fund_size", "currency", etc.
  # AUM and TER come as formatted strings often (e.g. "0.07%", "1,234 m").
  
  df_clean <- df %>%
    # Parse TER: Remove '%' and convert to numeric
    dplyr::mutate(
      ter_num = readr::parse_number(as.character(.data$ter))
    ) %>%
    # Parse AUM: Handle 'm' (millions) or 'bn' (billions) if present, though JustETF usually normalizes to millions in some views
    # Often it is just a formatted number.
    dplyr::mutate(
      aum_num = readr::parse_number(as.character(.data$fund_size))
    )
    
  # Apply filters
  # Note: AUM in JustETF search is often in the user's locale currency or GBP if country=GB?
  # Usually it's in GBP for country=GB.
  # LSE Listing: The search API usually returns metadata. 
  # It does NOT always explicitly list all exchanges in the main table.
  # We assume "country=GB" context implies available in UK, likely LSE.
  
  df_filtered <- df_clean %>%
    dplyr::filter(
      .data$aum_num >= min_aum_gbp,
      .data$ter_num <= max_ter
    )
  
  return(df_filtered)
}

# Cached screener snapshot for browser-safe use
get_cached_screener_data <- function(min_aum_gbp = 0, max_ter = 100) {
  if (!file.exists("vignette_data.rds")) {
    return(dplyr::tibble())
  }
  snap <- readRDS("vignette_data.rds")
  if (!all(c("metadata", "universe") %in% names(snap))) {
    return(dplyr::tibble())
  }
  snap$metadata |>
    dplyr::mutate(
      aum_num = readr::parse_number(.data$aum_text),
      ter_num = readr::parse_number(.data$ter_text)
    ) |>
    dplyr::left_join(snap$universe, by = "isin") |>
    dplyr::filter(
      .data$aum_num >= min_aum_gbp,
      .data$ter_num <= max_ter
    )
}

# --- Data (Embedded for WASM) ---

# Static seed list if live fetch fails (Embedded string removed, reading file)
# Since we cannot easily read file in WASM unless uploaded/available,
# we will rely on fetch_justetf_screener for "Live" data and fail gracefully.
# But user requested "seed_universe.csv" resource usage.
# We attempt to read it from current directory (if copied by resources).

get_etf_universe_static <- function(n = Inf) {
  if (file.exists("seed_universe.csv")) {
    seed_universe <- readr::read_csv("seed_universe.csv", show_col_types = FALSE)
    if (is.finite(n) && n < nrow(seed_universe)) {
      return(head(seed_universe, n))
    }
    return(seed_universe)
  }
  return(NULL)
}

# --- App UI & Server ---

# UI definition
ui <- htmltools::tagList(
  shiny::fluidPage(
    titlePanel("ETF Universe Explorer"),
    sidebarLayout(
      sidebarPanel(
        p("Explore the universe of ETFs."),
        selectInput("currencyFilter",
                    "Filter by Currency:",
                    choices = c("All", "GBP", "USD", "EUR"),
                    selected = "All"),
        sliderInput("minAUM",
                    "Minimum AUM (millions):",
                    min = 0,
                    max = 10000,
                    value = 0,
                    step = 100),
        actionButton("fetchLive", "Fetch Live JustETF Data")
      ),
      mainPanel(
        h3("Filtered ETF Data"),
        DT::dataTableOutput("etfTable"),
        h3("AUM vs TER (Live Data Only)"),
        plotOutput("aumTerPlot")
      )
    )
  )
)

# Server logic
server <- function(input, output, session) {

  # Load data
  universe_data <- reactiveVal(NULL)

  # Initial Load
  observe({
    # Try to load local seed file first
    static <- get_etf_universe_static()
    
    if (!is.null(static)) {
        static <- static %>% mutate(currency = as.character(currency))
        
        if (input$currencyFilter != "All") {
          static <- static %>% filter(currency == input$currencyFilter)
        }
        universe_data(static)
    } else {
        # If no static file, try fetch immediately (might fail if CORS)
        # Using isolate to avoid loop
        isolate({
             showNotification("Fetching live data...", duration = 3)
             res <- tryCatch({
               fetch_justetf_screener(min_aum_gbp = 0, max_ter = 100)
             }, error = function(e) {
               message("Live screener blocked: ", e$message)
               dplyr::tibble()
             })
             if (nrow(res) > 0) {
               universe_data(res)
             } else {
               cached <- get_cached_screener_data(min_aum_gbp = 0, max_ter = 100)
               if (nrow(cached) > 0) {
                 showNotification("Using cached screener snapshot.", type = "message", duration = 5)
                 universe_data(cached)
               }
             }
        })
    }
  })

  # Event for fetching live data
  observeEvent(input$fetchLive, {
    showNotification("Attempting to fetch live data...", duration = 5)
    
    fetched_data <- tryCatch(
      fetch_justetf_screener(min_aum_gbp = input$minAUM),
      error = function(e) {
        message("Error fetching live data: ", e$message)
        dplyr::tibble()
      }
    )
    if (nrow(fetched_data) > 0) {
      universe_data(fetched_data)
      showNotification("Live data fetched successfully!", type = "message", duration = 5)
    } else {
      cached <- get_cached_screener_data(min_aum_gbp = input$minAUM, max_ter = 100)
      if (nrow(cached) > 0) {
        universe_data(cached)
        showNotification("Live fetch blocked; using cached snapshot.", type = "warning", duration = 7)
      } else {
        showNotification("Failed to fetch live data or no data matched criteria.", type = "warning", duration = 5)
      }
    }
  })

  output$etfTable <- DT::renderDataTable({
    data <- universe_data()
    req(data)
    
    if (input$currencyFilter != "All" && "currency" %in% colnames(data)) {
        data <- data %>% filter(currency == input$currencyFilter)
    }
    
    cols <- c("ticker", "name", "currency", "fund_size", "ter")
    cols <- intersect(cols, colnames(data))
    
    data %>%
      select(all_of(cols)) %>%
      DT::datatable(options = list(pageLength = 10))
  })

  output$aumTerPlot <- renderPlot({
    data <- universe_data()
    req(data)
    
    if (input$currencyFilter != "All" && "currency" %in% colnames(data)) {
        data <- data %>% filter(currency == input$currencyFilter)
    }
    
    # Only plot if we have AUM and TER (from live fetch)
    if ("aum_num" %in% colnames(data) && "ter_num" %in% colnames(data)) {
       plot_data <- data %>%
        filter(!is.na(aum_num) & !is.na(ter_num)) %>%
        filter(aum_num >= input$minAUM)

      if (nrow(plot_data) > 0) {
          ggplot(plot_data, aes(x = aum_num, y = ter_num)) +
          geom_point(aes(color = currency), alpha = 0.7) +
          scale_x_log10(labels = scales::label_number(suffix = "M", scale_cut = scales::cut_short_scale())) +
          scale_y_log10(labels = scales::label_percent(scale = 1)) +
          labs(title = "AUM vs TER", x = "Assets Under Management", y = "Total Expense Ratio (%)") +
          theme_minimal()
      } else {
          ggplot() + annotate("text", x = 0.5, y = 0.5, label = "No data to plot") + theme_void()
      }
    } else {
       ggplot() + annotate("text", x = 0.5, y = 0.5, label = "Fetch live data to see plot") + theme_void()
    }
  })
}

shinyApp(ui, server)
```
