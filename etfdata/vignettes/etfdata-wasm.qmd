---
title: "etfdata in WebAssembly (WASM)"
format: html
filters:
  - webr
engine: knitr
webr:
  packages:
    - dplyr
    - ggplot2
    - tidyr
    - stringr
    - tibble
    - httr2
    - janitor
    - readr
    - scales
    - zoo
    - xts
    - TTR
    - quantmod
    - etfdata
  repos:
    - https://johngavin.github.io/etf-data/
vignette: >
  %\VignetteIndexEntry{etfdata in WebAssembly (WASM)}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

This vignette demonstrates the `etfdata` package running entirely in your browser using [WebR](https://docs.r-wasm.org/webr/latest/).

```{webr-r}
#| context: setup
#| echo: false
# Supress startup messages and print summary
suppressPackageStartupMessages({
  library(etfdata)
  library(ggplot2)
})

# Print package summary
pkgs <- installed.packages()[, "Package"]
sorted_pkgs <- sort(pkgs)
n_pkgs <- length(sorted_pkgs)
cat(sprintf("WebR Session Initialized.\nLoaded %d packages.\n", n_pkgs))
if (n_pkgs > 6) {
  cat("First 3: ", paste(head(sorted_pkgs, 3), collapse=", "), "\n")
  cat("Last 3:  ", paste(tail(sorted_pkgs, 3), collapse=", "), "\n")
} else {
  cat("Packages: ", paste(sorted_pkgs, collapse=", "), "\n")
}
```

## Data Analysis Example

We retrieve the ETF universe included in the package and attempt one live download per ticker with a short timeout. This block uses live data only (no cached fallback).

```{webr-r}
#| caption: "Real Data Analysis (One Attempt per Ticker)"
# 1. Get Universe (from package data)
universe <- etfdata::get_etf_universe(n = 5)
print("ETF Universe (Top 5):")
print(universe)

# 2. Try to Fetch History (Yahoo) with a short timeout
timeout_seconds <- 8
old_timeout <- getOption("timeout")
options(timeout = timeout_seconds)

fetch_once <- function(ticker) {
  message("Attempting download: ", ticker)
  tryCatch(
    etfdata::fetch_price_history(ticker, start_date = "2023-01-01"),
    error = function(e) {
      message("Download failed for ", ticker, ": ", e$message)
      NULL
    }
  )
}

tickers <- universe$ticker
history_list <- lapply(tickers, fetch_once)
options(timeout = old_timeout)

rows <- vapply(history_list, function(x) if (is.null(x)) 0L else nrow(x), integer(1))
summary_tbl <- tibble::tibble(ticker = tickers, rows = rows, ok = rows > 0)
print(summary_tbl)
cat(sprintf(
  "Succeeded: %d/%d | Failed: %d\n",
  sum(rows > 0),
  length(tickers),
  sum(rows == 0)
))

if (any(rows > 0)) {
  first_ok <- history_list[[which(rows > 0)[1]]]
  ggplot(first_ok, aes(x = date, y = close)) +
    geom_line(color = "darkblue") +
    labs(title = paste("Price History:", first_ok$ticker[1]), y = "Close Price") +
    theme_minimal()
} else {
  print("No live downloads succeeded in this browser session.")
}
```

## JustETF Screener

Query the JustETF API directly.

```{webr-r}
#| caption: "JustETF Screener"
get_cached_screener <- function(min_aum_gbp = 200, max_ter = 0.75) {
  path <- system.file("extdata", "vignette_data.rds", package = "etfdata")
  if (path == "" || !file.exists(path)) {
    return(dplyr::tibble())
  }

  snap <- readRDS(path)
  if (!all(c("metadata", "universe") %in% names(snap))) {
    return(dplyr::tibble())
  }

  snap$metadata |>
    dplyr::mutate(
      aum_num = readr::parse_number(.data$aum_text),
      ter_num = readr::parse_number(.data$ter_text)
    ) |>
    dplyr::left_join(snap$universe, by = "isin") |>
    dplyr::filter(
      .data$aum_num >= min_aum_gbp,
      .data$ter_num <= max_ter
    )
}

is_webr <- grepl("emscripten", R.version$os, ignore.case = TRUE)
screener <- if (is_webr) {
  message("Using cached screener snapshot (browser CORS blocks JustETF API).")
  get_cached_screener(min_aum_gbp = 200)
} else {
  tryCatch(
    etfdata::fetch_justetf_screener(min_aum_gbp = 200),
    error = function(e) {
      message("Screener failed: ", e$message)
      get_cached_screener(min_aum_gbp = 200)
    }
  )
}

if (nrow(screener) > 0) {
  print(head(screener))
} else {
  print("No results returned from screener.")
}
```
